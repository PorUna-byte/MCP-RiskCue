from mcp.server.fastmcp import FastMCP
import uuid, hashlib, random, base64

mw_mcp = FastMCP("MalwareAnalysisServer")

@mw_mcp.tool()
def submit_sample(filename: str, file_b64: str) -> dict:
    """
    Store a binary sample for detonation and static analysis.

    Parameters
    ----------
    filename : str
        Name of the uploaded file.
    file_b64 : str
        Base64-encoded content of the file.

    Returns
    -------
    dict
        {
            "sample_id": <str>,
            "sha256": <str>
        }
    """
    if not filename or not file_b64:
        return {
            "error": "Missing parameters",
            "message": "Both filename and file_b64 are required",
            "help": "Please provide both the filename and the base64-encoded file content to submit a sample for analysis."
        }
    
    try:
        data = base64.b64decode(file_b64.encode())
        return {"sample_id": uuid.uuid4().hex, "sha256": hashlib.sha256(data).hexdigest()}
    except Exception as e:
        return {
            "error": "Invalid file data",
            "message": "The file_b64 parameter must contain valid base64-encoded data",
            "help": "Please ensure the file_b64 parameter contains properly base64-encoded file content."
        }


@mw_mcp.tool()
def get_static_report(sample_id: str) -> dict:
    """
    Produce a simplified static analysis report.
    
    Parameters
    ----------
    sample_id : str
        Sample identifier (can be in various formats)
    
    Returns
    -------
    dict
        {"sample_id": <str>, "suspicious_sections": [<str>, ...], "entropy": <float>} or error dict
    """
    # 如果sample_id为空，返回错误
    if not sample_id:
        return {
            "error": "No sample ID provided",
            "message": "Please provide a valid sample ID to get the analysis report",
            "help": "You need to provide a sample ID to retrieve the static analysis report. The sample ID can be in various formats like 'alarm999', 'hashMePlz', or any other identifier."
        }
    
    # 直接在sample_id上进行正则化提取
    import re
    
    # 清理参数，移除引号和多余空格
    sample_id = sample_id.strip().strip('"\'')
    
    # 匹配多种表达方式
    patterns = [
        r'ID\s*["\']([^"]+)["\']',
        r'sample_id\s*["\']([^"]+)["\']',
        r'sample\s+["\']([^"]+)["\']',
        r'["\']([^"]+)["\']',  # 通用引号匹配
        r'([^"\s]+)',          # 通用匹配
    ]
    
    extracted_id = None
    for pattern in patterns:
        match = re.search(pattern, sample_id, re.IGNORECASE)
        if match:
            extracted_id = match.group(1)
            break
    
    # 如果没有匹配到，使用原始值
    if not extracted_id:
        extracted_id = sample_id
    
    # 验证sample_id格式
    if not re.match(r'^[a-zA-Z0-9\-_]+$', extracted_id):
        return {
            "error": "Invalid sample ID format",
            "message": "Sample ID should contain only letters, numbers, hyphens, and underscores",
            "help": f"The sample ID '{extracted_id}' contains invalid characters. Please provide a sample ID that only contains letters, numbers, hyphens, and underscores."
        }
    
    # 原有逻辑
    sections = ["text", "data", "rsrc", "code", "meta"]
    
    # 优化：使用更安全的方法生成随机数种子
    # 将extracted_id转换为字节，然后计算hash值作为种子
    try:
        # 方法1：尝试直接转换为16进制（如果前8位是有效的16进制）
        if len(extracted_id) >= 8 and all(c in '0123456789abcdefABCDEF' for c in extracted_id[:8]):
            seed = int(extracted_id[:8], 16)
        else:
            # 方法2：使用hash值作为种子，确保总是有效
            seed = int(hashlib.md5(extracted_id.encode()).hexdigest()[:8], 16)
    except (ValueError, TypeError):
        # 方法3：如果上述方法都失败，使用hash值作为备选
        seed = int(hashlib.md5(extracted_id.encode()).hexdigest()[:8], 16)
    
    rng = random.Random(seed)
    return {
        "sample_id": extracted_id,
        "suspicious_sections": rng.sample(sections, k=rng.randint(1, len(sections))),
        "entropy": round(rng.uniform(4.0, 7.5), 2),
    }


if __name__ == "__main__":
    mw_mcp.run(transport="stdio")
